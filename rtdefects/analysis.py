"""Functions to analyze segmented images"""
import logging
from warnings import warn
from typing import Iterator

from skimage import measure, morphology
from scipy.stats import siegelslopes
from scipy.interpolate import interp1d
import pandas as pd
import numpy as np

logger = logging.getLogger(__name__)


def analyze_defects(labeled_mask: np.ndarray, edge_buffer: int = 8) -> dict:
    """Analyze the voids in a masked image

    Args:
        labeled_mask: Mask for each of the segmented
        edge_buffer: Label voids as touching edge if they are within this many pixels of the side
    Returns:
        Dictionary of the computed properties
    """

    # Basic statistics
    output = {
        'void_frac': (labeled_mask > 0).sum() / (labeled_mask.shape[0] * labeled_mask.shape[1]),
        'void_count': int(labeled_mask.max())
    }

    # Create a 2D version of the image, where the pixel value is which defect that region "belongs to"
    if (labeled_mask > 0).sum(axis=0).max() > 1:
        warn('Some instances in this image overlap which each other. Talk to Logan about fixing it')
    object_inds = np.arange(labeled_mask.shape[0]) + 1
    with_index_3d = (labeled_mask > 0) * object_inds[:, None, None]
    with_index = with_index_3d.max(axis=0)

    # Compute region properties
    props = measure.regionprops(with_index, (with_index > 0))
    radii = [p['equivalent_diameter'] / 2 for p in props]
    output['type'] = labeled_mask.max(axis=(1, 2))
    output['radii'] = radii
    output['radii_average'] = np.average(radii)
    output['positions'] = [p['centroid'][::-1] for p in props]  # From (y, x) to (x, y)

    # Determine if it touches the side
    output['touches_side'] = [
        min(p['bbox']) <= edge_buffer
        or p['bbox'][2] >= labeled_mask.shape[0] - edge_buffer
        or p['bbox'][3] >= labeled_mask.shape[1] - edge_buffer
        for p in props
    ]

    return output


def label_instances_from_mask(mask: np.array, min_size: int = 50) -> np.ndarray:
    """Label distinct instances of defects within a larger void

    Args:
        mask: Boolean mask of isolated features
        min_size: Minimum size of defect (units: pixels)
    Returns:
        Image where distinct regions are labeled with different positive integers.
        Numpy array with be uint8.
    """

    # Clean up the mask
    mask = morphology.remove_small_objects(mask, min_size=min_size)
    mask = morphology.remove_small_holes(mask, min_size)
    mask = morphology.binary_erosion(mask, morphology.square(1))

    # Assign labels to the distinct regions
    output = measure.label(mask)
    assert output.max() < 256, f'Increase bit depth of our masks. This image has {output.max() + 1} objects'
    return np.array(output, dtype=np.uint8)


def convert_to_per_particle(per_frame: pd.DataFrame, position_col: str = 'positions') -> Iterator[pd.DataFrame]:
    """Convert the per-frame void information to the per-particle format expected by trackpy

    Args:
        per_frame: A DataFrame where each row is a different image and
            contains the defect locations in `positions` and sizes in `radii` columns.
        position_col: Name of the column holding positions of the particles
    Yields:
        A dataframe where each row is a different defect
    """

    for rid, row in per_frame.iterrows():
        particles = pd.DataFrame(row[position_col], columns=['x', 'y'])
        particles['local_id'] = np.arange(len(row['positions']))
        particles['frame'] = rid
        particles['radius'] = row['radii']
        particles['touches_side'] = row['touches_side']
        yield particles


def compute_drift(tracks: pd.DataFrame, minimum_tracks: int = 1) -> np.ndarray:
    """Estimate the drift for each frame from the positions of voids that were mapped between multiple frames

    We determine the "drift" based on the median displacement of all voids, which is based
    on the assumption that there is no net motion of all the voids.

    We compute the drift in each frame and assume the drift remains unchanged if there are no voids matched
    between a frame and the previous.

    In contrast, trackpy uses the mean and only computes drift when there are matches between frames.

    Args:
        tracks: Track information generated by trackpy.
        minimum_tracks: The minimum number of tracks a void must appear to be used in drift correction
    Returns:
        Drift correction for each frame
    """

    # We'll assume that the first frame has a void
    drifts = [(0, 0)]

    # We're going to go frame-by-frame and guess the drift from the previous frame
    last_frame = tracks.query('frame==0')
    for fid in range(1, tracks['frame'].max() + 1):
        # Join the two frames
        my_frame = tracks.query(f'frame=={fid}')
        aligned = last_frame.merge(my_frame, on='particle')

        # The current frame will be the previous for the next iteration
        last_frame = my_frame

        # If there are no voids in both frames, assign a drift change of 0
        if len(aligned) < minimum_tracks:
            drifts.append(drifts[-1])
            continue

        # Get the median displacements displacements
        last_pos = aligned[['x_x', 'y_x']].values
        cur_pos = aligned[['x_y', 'y_y']].values
        median_disp = np.mean(cur_pos - last_pos, axis=0)

        # Add the drift to that of the previous image
        drift = np.add(drifts[-1], median_disp)
        drifts.append(drift)

    return np.array(drifts)


def compile_void_tracks(tracks: pd.DataFrame) -> pd.DataFrame:
    """Compile summary statistics about each void

    Args:
        tracks: Track information for each void over time

    Returns:
        Dataframe of the summary of voids
        - "start_frame": First frame in which the void appears
        - "end_frame": Last frame in which the void appears
        - "total_frames": Total number of frames in which the void appears
        - "positions": Positions of the void in each frame
        - "touches_side": Whether the void touches the side at this frame
        - "local_id": ID of the void in each frame (if available)
        - "disp_from_start": How far the void has moved from the first frame
        - "max_disp": Maximum distance the void moved
        - "drift_rate": Average displacement from center over time
        - "dist_traveled": Total path distance the void has traveled
        - "total_travel": How far the void traveled over its whole life
        - "movement_rate": How far the void moves per frame
        - "radii": Radius of the void in each frame
        - "max_radius": Maximum radius of the void
        - "min_radius": Minimum radius of the void
        - "growth_rate": Median rate of change of the radius
    """

    # Loop over all unique voids
    voids = []
    for t, track in tracks.groupby('particle'):
        # Get the frames where this void is visible
        visible_frames = track['frame']

        # Get all frames between start and stop
        frames_id = np.arange(track['frame'].min(), track['frame'].max() + 1)

        # Build an interpolator for position as a function of frame
        if len(track) == 1:
            positions = track[['x', 'y']].values
        else:
            x_inter = interp1d(track['frame'], track['x'])
            y_inter = interp1d(track['frame'], track['y'])

            # Compute the displacement over each step
            positions = [(x_inter(f), y_inter(f)) for f in frames_id]
            positions = np.array(positions)

        # Get the ID from each frame and whether it touches the side
        id_lookup = dict(zip(track['frame'], track['local_id']))
        local_id = [id_lookup.get(i, None) for i in frames_id]

        # Use interpolation to detect if any point used to interpolate
        #  the void position was on the side
        if len(track) == 1:
            touches_side = track['touches_side'].values
        else:
            ts_inter = interp1d(track['frame'], np.array(track['touches_side'], dtype=float), kind='linear')
            touches_side = ts_inter(frames_id) > 0  # It is only zero if neither point used in the left or right touches side (and equals 1)

        # Gather some basic information about the void
        void_info = {
            'start_frame': np.min(visible_frames),
            'end_frame': np.max(visible_frames),
            'total_frames': len(frames_id),
            'inferred_frames': len(frames_id) - len(track),
            'positions': positions,
            'touches_side': touches_side,
            'local_id': local_id
        }

        # If there is only one frame, we cannot do the following steps
        if positions.shape[0] > 1:
            # Compute the displacement from the start
            void_info['disp_from_start'] = np.linalg.norm(positions - positions[0, :], axis=1)
            void_info['max_disp'] = np.max(void_info['disp_from_start'])
            void_info['drift_rate'] = void_info['max_disp'] / void_info['total_frames']

            # Get the displacement for each step
            void_info['dist_traveled'] = np.concatenate(([0], np.cumsum(np.linalg.norm(np.diff(positions, axis=0), axis=1))))
            void_info['total_traveled'] = void_info['dist_traveled'][-1]
            void_info['movement_rate'] = void_info['total_traveled'] / void_info['total_frames']

        # More stats if we have radii
        if len(track) == 1:
            radii = track['radius'].values
        else:
            r_inter = interp1d(track['frame'], track['radius'])
            radii = r_inter(frames_id)

        # Store some summary information
        void_info['radii'] = radii
        void_info['max_radius'] = max(radii)
        void_info['min_radius'] = min(radii)
        if len(radii) > 3:
            void_info['growth_rate'] = siegelslopes(radii)[0]

        # Add it to list
        voids.append(void_info)
    return pd.DataFrame(voids)
