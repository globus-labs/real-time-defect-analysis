"""Functions to analyze segmented images"""
import logging
from typing import Iterator, Tuple

from skimage import measure, morphology
from scipy.stats import siegelslopes
from scipy.interpolate import interp1d
import pandas as pd
import numpy as np

logger = logging.getLogger(__name__)


def analyze_defects(mask: np.ndarray, min_size: int = 50) -> Tuple[dict, np.ndarray]:
    """Analyze the voids in a masked image

    Args:
        mask: Masks for a defect image
        min_size: Minimum size of defects
    Returns:
        - Dictionary of the computed properties
        - Labeled images
    """

    # Clean up the mask
    mask = morphology.remove_small_objects(mask, min_size=min_size)
    mask = morphology.remove_small_holes(mask, min_size)
    mask = morphology.binary_erosion(mask, morphology.square(1))
    output = {'void_frac': mask.sum() / (mask.shape[0] * mask.shape[1])}

    # Assign labels to the labeled regions
    labels = measure.label(mask)
    output['void_count'] = int(labels.max())

    # Compute region properties
    props = measure.regionprops(labels, mask)
    radii = [p['equivalent_diameter'] / 2 for p in props]
    output['radii'] = radii
    output['radii_average'] = np.average(radii)
    output['positions'] = [p['centroid'][::-1] for p in props]  # From (y, x) to (x, y)
    return output, labels


def convert_to_per_particle(per_frame: pd.DataFrame, position_col: str = 'positions') -> Iterator[pd.DataFrame]:
    """Convert the per-frame void information to the per-particle format expected by trackpy

    Args:
        per_frame: A DataFrame where each row is a different image and
            contains the defect locations in `positions` and sizes in `radii` columns.
        position_col: Name of the column holding positions of the particles
    Yields:
        A dataframe where each row is a different defect
    """

    for rid, row in per_frame.iterrows():
        particles = pd.DataFrame(row[position_col], columns=['x', 'y'])
        particles['local_id'] = np.arange(len(row['positions']))
        particles['frame'] = rid
        particles['radius'] = row['radii']
        yield particles


def compute_drift(tracks: pd.DataFrame, minimum_tracks: int = 1) -> np.ndarray:
    """Estimate the drift for each frame from the positions of voids that were mapped between multiple frames

    We determine the "drift" based on the median displacement of all voids, which is based
    on the assumption that there is no net motion of all the voids.

    We compute the drift in each frame and assume the drift remains unchanged if there are no voids matched
    between a frame and the previous.

    In contrast, trackpy uses the mean and only computes drift when there are matches between frames.

    Args:
        tracks: Track information generated by trackpy.
        minimum_tracks: The minimum number of tracks a void must appear to be used in drift correction
    Returns:
        Drift correction for each frame
    """

    # We'll assume that the first frame has a void
    drifts = [(0, 0)]

    # We're going to go frame-by-frame and guess the drift from the previous frame
    last_frame = tracks.query('frame==0')
    for fid in range(1, tracks['frame'].max() + 1):
        # Join the two frames
        my_frame = tracks.query(f'frame=={fid}')
        aligned = last_frame.merge(my_frame, on='particle')

        # The current frame will be the previous for the next iteration
        last_frame = my_frame

        # If there are no voids in both frames, assign a drift change of 0
        if len(aligned) < minimum_tracks:
            drifts.append(drifts[-1])
            continue

        # Get the median displacements displacements
        last_pos = aligned[['x_x', 'y_x']].values
        cur_pos = aligned[['x_y', 'y_y']].values
        median_disp = np.mean(cur_pos - last_pos, axis=0)

        # Add the drift to that of the previous image
        drift = np.add(drifts[-1], median_disp)
        drifts.append(drift)

    return np.array(drifts)


def compile_void_tracks(tracks: pd.DataFrame) -> pd.DataFrame:
    """Compile summary statistics about each void

    Args:
        tracks: Track information for each void over time

    Returns:
        Dataframe of the summary of voids
        - "start_frame": First frame in which the void appears
        - "end_frame": Last frame in which the void appears
        - "total_frames": Total number of frames in which the void appears
        - "positions": Positions of the void in each frame
        - "local_id": ID of the void in each frame (if available)
        - "disp_from_start": How far the void has moved from the first frame
        - "max_disp": Maximum distance the void moved
        - "drift_rate": Average displacement from center over time
        - "dist_traveled": Total path distance the void has traveled
        - "total_travel": How far the void traveled over its whole life
        - "movement_rate": How far the void moves per frame
        - "radii": Radius of the void in each frame
        - "max_radius": Maximum radius of the void
        - "min_radius": Minimum radius of the void
        - "growth_rate": Median rate of change of the radius
    """

    # Loop over all unique voids
    voids = []
    for t, track in tracks.groupby('particle'):
        # Get the frames where this void is visible
        visible_frames = track['frame']

        # Get all frames between start and stop
        frames_id = np.arange(track['frame'].min(), track['frame'].max() + 1)

        # Build an interpolator for position as a function of frame
        if len(track) == 1:
            positions = track[['x', 'y']].values
        else:
            x_inter = interp1d(track['frame'], track['x'])
            y_inter = interp1d(track['frame'], track['y'])

            # Compute the displacement over each step
            positions = [(x_inter(f), y_inter(f)) for f in frames_id]
            positions = np.array(positions)

        # Get the ID from each frame
        id_lookup = dict(zip(track['frame'], track['local_id']))
        local_id = [id_lookup.get(i, None) for i in frames_id]

        # Gather some basic information about the void
        void_info = {
            'start_frame': np.min(visible_frames),
            'end_frame': np.max(visible_frames),
            'total_frames': len(frames_id),
            'inferred_frames': len(frames_id) - len(track),
            'positions': positions,
            'local_id': local_id
        }

        # If there is only one frame, we cannot do the following steps
        if positions.shape[0] > 1:
            # Compute the displacement from the start
            void_info['disp_from_start'] = np.linalg.norm(positions - positions[0, :], axis=1)
            void_info['max_disp'] = np.max(void_info['disp_from_start'])
            void_info['drift_rate'] = void_info['max_disp'] / void_info['total_frames']

            # Get the displacement for each step
            void_info['dist_traveled'] = np.concatenate(([0], np.cumsum(np.linalg.norm(np.diff(positions, axis=0), axis=1))))
            void_info['total_traveled'] = void_info['dist_traveled'][-1]
            void_info['movement_rate'] = void_info['total_traveled'] / void_info['total_frames']

        # More stats if we have radii
        if len(track) == 1:
            radii = track['radius'].values
        else:
            r_inter = interp1d(track['frame'], track['radius'])
            radii = r_inter(frames_id)

        # Store some summary information
        void_info['radii'] = radii
        void_info['max_radius'] = max(radii)
        void_info['min_radius'] = min(radii)
        if len(radii) > 3:
            void_info['growth_rate'] = siegelslopes(radii)[0]

        # Add it to list
        voids.append(void_info)
    return pd.DataFrame(voids)
